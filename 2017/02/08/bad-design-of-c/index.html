<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="编程语言,C,"><meta name="description" content="日常使用中，可能不时觉得某些编程语言里面有一些不好用的地方。当然大多设计都同时有优缺点，我们要理解其中的权衡。 不过以现在的眼光来看，以前有些设计的缺点明显大于优点，这就不能完全推脱为权衡，而可以称之为设计失误了。当然两者的界限不太分明，见仁见智，这里就谈谈我的看法。我准备总结并吐槽一下我平时使用过的一些编程语言的种种设计问题。当然不是为了批评，有些语言是在几十年前设计的，在当时缺乏足够的实践教训"><meta name="keywords" content="编程语言,C"><meta property="og:type" content="article"><meta property="og:title" content="C的设计失误"><meta property="og:url" content="https://vegarden.github.io/2017/02/08/bad-design-of-c/index.html"><meta property="og:site_name" content="菜鸟的自我修养"><meta property="og:description" content="日常使用中，可能不时觉得某些编程语言里面有一些不好用的地方。当然大多设计都同时有优缺点，我们要理解其中的权衡。 不过以现在的眼光来看，以前有些设计的缺点明显大于优点，这就不能完全推脱为权衡，而可以称之为设计失误了。当然两者的界限不太分明，见仁见智，这里就谈谈我的看法。我准备总结并吐槽一下我平时使用过的一些编程语言的种种设计问题。当然不是为了批评，有些语言是在几十年前设计的，在当时缺乏足够的实践教训"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2017-10-04T07:16:17.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="C的设计失误"><meta name="twitter:description" content="日常使用中，可能不时觉得某些编程语言里面有一些不好用的地方。当然大多设计都同时有优缺点，我们要理解其中的权衡。 不过以现在的眼光来看，以前有些设计的缺点明显大于优点，这就不能完全推脱为权衡，而可以称之为设计失误了。当然两者的界限不太分明，见仁见智，这里就谈谈我的看法。我准备总结并吐槽一下我平时使用过的一些编程语言的种种设计问题。当然不是为了批评，有些语言是在几十年前设计的，在当时缺乏足够的实践教训"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://vegarden.github.io/2017/02/08/bad-design-of-c/"><title>C的设计失误 | 菜鸟的自我修养</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">菜鸟的自我修养</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://vegarden.github.io/2017/02/08/bad-design-of-c/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="vegarden"><meta itemprop="description" content=""><meta itemprop="image" content="/images/poi.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="菜鸟的自我修养"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">C的设计失误</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-08T23:23:23+08:00">2017-02-08 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2017-10-04T15:16:17+08:00">2017-10-04 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/吹毛求疵/" itemprop="url" rel="index"><span itemprop="name">吹毛求疵</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>日常使用中，可能不时觉得某些编程语言里面有一些不好用的地方。当然大多设计都同时有优缺点，我们要理解其中的权衡。 不过以现在的眼光来看，以前有些设计的缺点明显大于优点，这就不能完全推脱为权衡，而可以称之为设计失误了。当然两者的界限不太分明，见仁见智，这里就谈谈我的看法。</p><p>我准备总结并吐槽一下我平时使用过的一些编程语言的种种设计问题。当然不是为了批评，有些语言是在几十年前设计的，在当时缺乏足够的实践教训和前人经验（或者是缺乏经验导致的不重视设计细节）的情况下，这些问题都是情有可原的（不过某些所谓现代语言仍然继承了，甚至自创了一些设计失误就值得批判了）。总结这些设计失误，一是引起重视，帮助我们在使用中尽量避免一些问题，二是帮助我们理解一些现代语言为何采取了不同的设计。</p><p>这里，就先从大名鼎鼎的C开刀（设计并不全部由C首创，但是起码照搬了没改，同时也影响深远），有些在新标准里面有所改善。另外考虑到C的年龄，从缺乏特性挑刺有点欺负人，这点就尽量不谈。</p><a id="more"></a><h3 id="变量默认可变"><a href="#变量默认可变" class="headerlink" title="变量默认可变"></a>变量默认可变</h3><p>声明变量默认是可变的，声明不可变变量需要额外加上<code>const</code>进行修饰。</p><p>我们要知道</p><ul><li>内存及线程不安全的根源是共享和可变性的共存。而当确定一个对象不可变时，我们就可以放心地共享它，同时方便编译器进行更彻底的优化。</li><li>默认不可变更有利于程序的安全性。默认不可变时，如果我们修改了不可变变量，就会被编译器警告，我们确认是否真的需要这个变量可变，然后进行修改；变量默认可变的情况下，我们经常将不需变化的变量声明为可变的，编译器并没有什么意见，如果误改了不应该变化的变量较难发现。</li><li>实际使用中，需要变化的变量并不显著多于固定的变量，特别是我们鼓励多使用中间变量提高可读性的情况下，不需变化的变量就更多，同时编译器的优化也能保证更多的中间变量并不会增加存储空间和性能的消耗。</li></ul><p>从以上原因来看，可变和不可变中，如果要选择一个作为默认，有什么理由选择可变呢？</p><blockquote><p>另外有些语言里也有可变与不可变地位平等，没有哪个是所谓的默认，比如<code>val</code>声明不可变，<code>var</code>声明可变。当然，基于以上理由，个人还是更倾向默认不可变。</p></blockquote><h3 id="基础类型偏执"><a href="#基础类型偏执" class="headerlink" title="基础类型偏执"></a>基础类型偏执</h3><p>其实这里讲的问题严格上不是基础类型偏执，但是对这个问题我没有找到合适的专有名词。</p><p>基础类型偏执，是指某些人偏好并尽可能使用基础类型，而不是定义一个新类型进行抽象，从而影响可读性和可重用性；主要是针对程序员编程的时候，偏向于使用基础类型，而不是构造复合类型。我这里讲的主要针对于语言设计的时候把不同用途的东西归于一个类型。严格来讲这是两个不同的问题，但是其背后的思想是相通的，带来的危害几乎是相同的。所以这里就当它也是基础类型偏执。</p><h4 id="Type-rich-Programming"><a href="#Type-rich-Programming" class="headerlink" title="Type-rich Programming"></a>Type-rich Programming</h4><p>先讲讲基础类型偏执的反面，有一种叫Type-rich Programming的思想。Type-rich Programming大概就是把不同单位和用途的东西用不同的类型表示，充分利用语言自身的类型系统，在编译期进行更多检查，便于开发时就发现更多隐藏的错误。<br>比如下面这个比较极端的例子，就有效防止了年月日都是整数类型而把参数顺序写错。虽然例子不太靠谱，这也说明了Type-rich Programming的一种应用。<br></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Year</span></span>(<span class="built_in">usize</span>);</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Month</span></span>(<span class="built_in">usize</span>);</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span></span>(<span class="built_in">usize</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_date</span></span>(y: Year, m: Month, d: Day) &#123;</div><div class="line">    <span class="keyword">let</span> Year(y) = y;</div><div class="line">    <span class="keyword">let</span> Month(m) = m;</div><div class="line">    <span class="keyword">let</span> Day(d) = d;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, y, m, d);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    print_date(Year(<span class="number">2017</span>), Month(<span class="number">9</span>), Day(<span class="number">12</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>我们无视上面这种可以把程序员累死的风格，下面讲点实际的东西。</p><h4 id="回到C"><a href="#回到C" class="headerlink" title="回到C"></a>回到C</h4><p>C（特别早期的C）里面有一种倾向，只要底层实现相同，则可以归为一种类型，比如没有单独的<code>bool</code>类型，8位整数和字符是一种类型。类似的思想又带来了C接口上的一种惯例，当概念上需要多个类型时，使用一个基本类型，并把多种类型映射到它的不同值区间，比如0表示正常，负值表示错误；空指针表示错误，否则正常。虽然从功能上没什么损失，但是降低可读性，同时更容易造成人为的编码错误。</p><h5 id="没有独立的bool类型"><a href="#没有独立的bool类型" class="headerlink" title="没有独立的bool类型"></a>没有独立的bool类型</h5><p>就拿没有单独的<code>bool</code>类型来说，C最开始没有专门的<code>bool</code>类型，任何类型都可以当作<code>bool</code>，二进制表示非零则认为是<code>true</code>，全零则认为是<code>false</code>，最常见的是使用整型作为<code>bool</code>使用。不小心就可能把一个有其他含义的数值当成<code>bool</code>使用。比如比较函数，使用小于0，等于0，大于0的整数分别表示小于，等于，大于。</p><p>要比较两个对象相同，可以这样<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cmp(a, b) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">/* code */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>但是一不小心，写漏了返回值的判断，变成<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cmp(a, b)) &#123;</div><div class="line">    <span class="comment">/* code */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>乍一看没啥特别不对的地方，编译器也没什么异议，直接把返回值当<code>bool</code>类型用了，并不知道它是别的含义，相信不少人写过这种bug。</p><p>如果有单独的<code>bool</code>类型，供条件语句使用，同时不允许整数到<code>bool</code>的隐式转化，这里编译器就能纠正你，<code>cmp(a, b)</code>返回的不是一个<code>bool</code>类型，所以不能作为<code>if</code>后面的条件使用。虽然C后来的标准中加入了<code>bool</code>类型，但是由于兼容性原因，整数仍旧可以被隐式转化为<code>bool</code>，仍不能防止误用；值得欣慰的是GCC 7.0会对此有警告，然而实际生产环境基本没有地方会用这么新的版本，一些历史代码使用整型表示<code>bool</code>也需要大量的修改。<br>当然这里的问题不只是<code>bool</code>，其实比较函数的返回值应该定义一个<code>enum</code>，也不该是整数。不过说起来C的<code>enum</code>也不够到位，只是对整型的简单封装。</p><h5 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h5><p>C里面一开始<code>char</code>就是一个8位整数，因为当时他们觉得ASCII字符和8位整数本质上就是一样的；另外字符串就是<code>char</code>的数组。</p><p>于是后来需要支持各种语言的各种奇妙字符时，就发现需要定义两字节的宽字符类型，而不能复用<code>char</code>。再后来，大家开始使用Unicode的时候，字符串都不能用字符数组来表示了，因为Unicode字符都未必等长，必须搞个专门的字符串类型了，而这其实一早就该抽象出来。</p><p>没有根据用途定义不同的类型，就造成场景变化后无法重用，这就是个典型例子，如果把字符和字符串这种用途上不同的就抽象为专门的类型，起码能够自然地在扩展时达到代码的重用（当然对C来说，就算复用代码，编译出的库也不能复用，并不能完全兼容）。</p><h5 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h5><p>虽然很多人可能没有意识到，空指针也是基础类型偏执的一种。空指针的设计属于，把多种不同的类型，映射到同一类型的不同值区间。</p><p>这里其实是说，空指针和真正指向正确目标的指针，应该是两种不同的类型。因为类型应当是相同行为的值的一个集合，而这两种指针的行为并不相同。解引用一个正常指针能得到一个值，解引用一个空指针，在C标准上来说是未定义行为，在实际实现中一般是段错误。</p><p>空指针这么多年来带来了不计其数的bug和经济损失，连其发明者都称之为”billion dollar mistake”。</p><p>至于把空指针作为一种类型的设计到底是如何操作的，之后会在另一篇文章介绍。</p><h3 id="副作用返回值共存的运算符"><a href="#副作用返回值共存的运算符" class="headerlink" title="副作用返回值共存的运算符"></a>副作用返回值共存的运算符</h3><p>C中有<code>++</code>和<code>--</code>这样的自增操作符，经常被人滥用，只为了写出简短的代码。</p><h4 id="未定义的求值顺序"><a href="#未定义的求值顺序" class="headerlink" title="未定义的求值顺序"></a>未定义的求值顺序</h4><p>一旦我们在同一个表达式中使用了多个自增操作，像<code>x++ + ++x</code>，其求值顺序就属于未定义行为，在不同编译器实现中可以不同。</p><p>所谓未定义行为，就是从规范上不应该出现的行为，标准没有规定。碰到之后编译器干任何事情都是符合标准的（比如编译出人工智能程序接管你的电脑；再比如通过啥恶意代码把你的硬件烧掉一些啥的（当然符合C标准不代表合法））。<br>据说GCC的早期版本有个彩蛋，在遇到未定义行为时会尝试打开机器里的某些游戏（真是温柔）。</p><p>更糟的是，曾有人堂而皇之地把这种代码写进教科书，并一本正经地分析其求值顺序，流毒甚远。</p><h4 id="返回值造成的另一个问题"><a href="#返回值造成的另一个问题" class="headerlink" title="返回值造成的另一个问题"></a>返回值造成的另一个问题</h4><p>赋值语句具有返回值，于是我们可以写<code>x = y = 0</code>。看起来比较方便，但是同时也可能出现<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x = <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">/* code */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这样的误用，if的条件语句中判断相等的<code>==</code>少打成<code>=</code>，但语法仍然是合法的（这有两个问题，一是赋值根本不应该有返回值；另一个是前面提到的整型不应该隐式转化为<code>bool</code>类型用于分支判断）。</p><p>这一类问题的根源在于不必要地追求语法的短小（短得有限，而且分开两句写逻辑可能更清晰），同时具有副作用和返回值的运算符完全不必要，还容易出错。</p><p><code>x++</code>完全可以使用<code>x += 1</code>或<code>x = x + 1</code>代替，虽然后面两个式子同样具有着返回值，但是看起来更像单纯的赋值，更容易给人不去使用其返回值的心理暗示（当然最好能直接去掉其返回值，虽然为了向下兼容这是不可能的）。</p><p>所以，我一般在使用C的时候，使用<code>+= 1</code>，<code>-= 1</code>代替自增自减，这样更能提醒自己不去使用其返回值。</p><h3 id="简陋的宏变换"><a href="#简陋的宏变换" class="headerlink" title="简陋的宏变换"></a>简陋的宏变换</h3><p>宏其实就是编译阶段对代码的变换。</p><p>C的宏的实现方式为字符串替换，作用于词法分析之前。过于简单粗暴，容易出错，功能也有限。<br>这样的宏不是清洁宏，宏里面使用的中间变量可能污染作用域，恰好外面也使用相同变量名的话，就可能导致奇怪的行为。<br>另外一般使用的时候，我们心理上容易把宏当成和语句或函数差不多的东西，但是实际上一个类似于<code>#define foo } else {</code>或者<code>#define bar ); sth()</code>的宏的实际行为能完全超出你的预料之外。<br>仔细一想我们发现，这个问题和SQL注入的原理简直一模一样。</p><p>如果我们了解宏的问题所在，使用时尽量谨慎，其危害还是可控的，毕竟代码是在自己控制之下的，该变换的在编译时都确定了。不像SQL需要在接受并拼接外部的输入后，再进行语句的分析。<br>但一个很大的问题就是，并不是很多人都能意识到这个问题，谨慎地使用宏。不少C程序员会滥用宏，还引以为傲，颇为得意。不少使用宏的地方都可以使用内联函数，全局常量替代，而且相信编译器，这几乎没有性能或内存的代价。<br>另外一部分问题是，有的时候我们想减少重复代码，发现不用宏无法实现。其主要原因是由于C没有泛型或函数重载，比如可作用于所有可比较类型的max函数，就需要通过代码变换来绕开函数的类型限制。</p><p>宏并不是什么必需的功能，当然宏也是个有用的语言特性，可以是对语言功能的有益补充，但是需要好好考虑宏的设计（当然这个问题很复杂），比如考虑是对抽象语法树进行变换而不是对字符串进行变换，宏变换只能影响到自己内部，不会对语法树的上层造成影响之类的。</p><h3 id="分号空语句"><a href="#分号空语句" class="headerlink" title="分号空语句"></a>分号空语句</h3><p>允许单独的一个分号<code>;</code>作为空语句存在的语法。<br>于是有时没注意，可能出现这样的代码<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>);</div><div class="line">&#123;</div><div class="line">    <span class="comment">/* code */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>while (true)</code>后面的<code>;</code>被视为空语句，并被作为循环体，结果进入了空语句循环，真正要循环的代码被遗弃在一边。</p><p>大概有两种解决方案</p><ul><li>禁止使用分号作为空语句，真的需要空语句的地方，使用一对大括号<code>{}</code>完全可以达到要求，不易手滑写错也更加显眼</li><li>要求<code>if</code>,<code>for</code>,<code>while</code>后面跟随的必须是语句块而不能是单个语句（循环和条件语句后面只有一句语句的时候可以省略大括号，本来就是一个编码隐患，要求<code>if</code>,<code>for</code>,<code>while</code>后面必须跟随不省略大括号的语句块这一点被写进了不少编程规范中，其实不如干脆在语言语法中要求）</li></ul><h3 id="switch默认fallthrough"><a href="#switch默认fallthrough" class="headerlink" title="switch默认fallthrough"></a>switch默认fallthrough</h3><p><code>switch</code>语句中的每个<code>case</code>，结束的默认行为是<code>fallthrough</code>，继续运行下一个<code>case</code>，也是一个潜在的bug制造点。这一点很反直觉，而且绝大多数情况我们都需要返回。不少现代语言都已经改变其默认行为返回。</p><p>那么C为什么一开始采用如此奇怪的实现方式呢？我估计主要是多种可能取值属于同一种情况的时候<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (cond) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="comment">/* code */</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">    <span class="comment">/* more */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这里由于<code>case 1</code>往下走了，才能和<code>case 2</code>共用一段代码。如果要改为默认返回的话，就需要额外声明<code>case 1</code>需要<code>fallthrough</code>。这是我对C为什么这样设计的猜测，不过个人挺奇怪为什么这么解决，我觉得有个更好的解决方案，就是支持一个<code>case</code>包含多个值的语法，比如<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (cond) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</div><div class="line">        <span class="comment">/* code */</span></div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">    <span class="comment">/* more */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这样就比较自然。</p><p>当然语言为了向下兼容，不能乱改，另一个比较实际的解决方案是GCC 7.0对每个<code>case</code>结尾没有break会有警告，除非我们在<code>case</code>结尾的位置使用<code>__attribute__((fallthrough))</code>属性标注或类似与<code>/* Fall Through */</code>的注释才能消除警告。说起来GCC的新版本不断增加新的警告，所以我见过有些编译选项里写了<code>-Wall -Werror</code>的项目升级编译器版本就直接各种编译失败了。</p><h3 id="八进制整数字面量"><a href="#八进制整数字面量" class="headerlink" title="八进制整数字面量"></a>八进制整数字面量</h3><p>以0开头的整数字面量被识别为八进制，想必也坑了一些人。按直觉和数学知识来看，数字前面的前导0对值应该没有影响。我觉得不如仿照十六进制的形式，使用类似于0o开头作为八进制的语法，在很多新语言里面都是这样的用法。</p><p>不过C里面为了兼容没法改，这点只能停留在吐槽了吧。</p><h3 id="数字类型名"><a href="#数字类型名" class="headerlink" title="数字类型名"></a>数字类型名</h3><p>C中的各种整数类型，除了和八位ASCII码字符类型共用的char之外，都是由零至多个修饰词<code>short</code>，<code>long</code>和类型名<code>int</code>组成的（使用修饰词时可省略<code>int</code>）。<br>另外还有利用<code>long</code>在32位和64位机器上长度不同，用来表示和指针长度相同的整型，这样一个非常不直观的潜规则。</p><p>其实这些整数类型，除了位数不同（先不考虑正负），没有其他区别。这样的表示法要多记一层对应关系（再考虑32位和64为有不同的对应关系），增加了记忆理解负担，也不方便更大位数的扩展。</p><p>增加记忆理解负担好理解，为什么说不方便更大数位的扩展呢？看看下面这个蛋疼且无用的推理和那张对应表吧，不想看随便略过。<br>假设我们以后有了128位的计算机（我好像已经看到一些硬件开始支持128位整数了），我们还坚持使用这种类型命名方式，考虑一下整数类型和长度的关系吧。<br>char作为一个ASCII字符，长度8位应该不变吧。现有的32位和64位机器上的类型长度也不能改。还有我们是不是要考虑<code>long</code>和指针等长的惯例，如果推翻这一点，有些兼容性代码就不太容易写出，那假设这一条也成立吧，那么128位上的<code>long</code>就得是128位了。<br>然后从过渡时期开始，64位机器就会支持128位整数吧，那现在<code>long long</code>已经是64位了，128位我们要给个<code>long long long</code>吧，<code>long long long</code>和<code>long long</code>在128位机器上也要有意义，介于<code>long</code>都已经128位了，它们也只能都是128位吧。于是128位机器的<code>long</code>,<code>long long</code>,<code>long long long</code>全成了128位整数。<br>那还剩下16,32,64位的整数我们要在128位机器上表示，但是我们的类型只剩<code>short</code>,<code>int</code>了。那我们要么在char和short中间插入一个<code>short short</code>表示16位；要么推翻<code>long</code>和指针等长的潜规则，让128位机器上的<code>long</code>成为64位。<br>总之在这之前我们应该早就抛弃这种类型命名了。</p><table><thead><tr><th></th><th>32</th><th>64</th><th>128</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td><td>8</td></tr><tr><td>short short</td><td>16</td><td>16</td><td>16</td></tr><tr><td>short</td><td>16</td><td>16</td><td>32(16)</td></tr><tr><td>int</td><td>32</td><td>32</td><td>64(32)</td></tr><tr><td>long</td><td>32</td><td>64</td><td>128(64)</td></tr><tr><td>long long</td><td>64</td><td>64</td><td>128</td></tr><tr><td>long long long</td><td>/</td><td>128</td><td>128</td></tr></tbody></table><p>C语言后来的标准也意识到这个问题，引入新的类型别名<code>int8_t</code>,<code>int16_t</code>,<code>int32_t</code>,<code>int64_t</code>,<code>intptr_t</code>等，使用相同的前缀后缀，直接在类姓名中写明长度，而<code>intptr_t</code>顾名思义就是和指针等长的。很多现代语言也采取了这种类型命名方式。这样的类型名能直观地看出每种类型的长度，便于记忆，而且统一，具有扩展性。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> vegarden</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://vegarden.github.io/2017/02/08/bad-design-of-c/" title="C的设计失误">https://vegarden.github.io/2017/02/08/bad-design-of-c/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/编程语言/" rel="tag"># 编程语言</a> <a href="/tags/C/" rel="tag"># C</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/09/25/rust-1/" rel="next" title="Rust-1.RAII"><i class="fa fa-chevron-left"></i> Rust-1.RAII</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/12/04/rust-2/" rel="prev" title="Rust-2.错误处理">Rust-2.错误处理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/poi.gif" alt="vegarden"><p class="site-author-name" itemprop="name">vegarden</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/vegarden" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量默认可变"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x53D8;&#x91CF;&#x9ED8;&#x8BA4;&#x53EF;&#x53D8;" class="headerlink" title="&#x53D8;&#x91CF;&#x9ED8;&#x8BA4;&#x53EF;&#x53D8;"></a>&#x53D8;&#x91CF;&#x9ED8;&#x8BA4;&#x53EF;&#x53D8;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础类型偏执"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x57FA;&#x7840;&#x7C7B;&#x578B;&#x504F;&#x6267;" class="headerlink" title="&#x57FA;&#x7840;&#x7C7B;&#x578B;&#x504F;&#x6267;"></a>&#x57FA;&#x7840;&#x7C7B;&#x578B;&#x504F;&#x6267;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Type-rich-Programming"><span class="nav-number">2.1.</span> <span class="nav-text"><a href="#Type-rich-Programming" class="headerlink" title="Type-rich Programming"></a>Type-rich Programming</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回到C"><span class="nav-number">2.2.</span> <span class="nav-text"><a href="#&#x56DE;&#x5230;C" class="headerlink" title="&#x56DE;&#x5230;C"></a>&#x56DE;&#x5230;C</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#没有独立的bool类型"><span class="nav-number">2.2.1.</span> <span class="nav-text"><a href="#&#x6CA1;&#x6709;&#x72EC;&#x7ACB;&#x7684;bool&#x7C7B;&#x578B;" class="headerlink" title="&#x6CA1;&#x6709;&#x72EC;&#x7ACB;&#x7684;bool&#x7C7B;&#x578B;"></a>&#x6CA1;&#x6709;&#x72EC;&#x7ACB;&#x7684;bool&#x7C7B;&#x578B;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符和字符串"><span class="nav-number">2.2.2.</span> <span class="nav-text"><a href="#&#x5B57;&#x7B26;&#x548C;&#x5B57;&#x7B26;&#x4E32;" class="headerlink" title="&#x5B57;&#x7B26;&#x548C;&#x5B57;&#x7B26;&#x4E32;"></a>&#x5B57;&#x7B26;&#x548C;&#x5B57;&#x7B26;&#x4E32;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#空指针"><span class="nav-number">2.2.3.</span> <span class="nav-text"><a href="#&#x7A7A;&#x6307;&#x9488;" class="headerlink" title="&#x7A7A;&#x6307;&#x9488;"></a>&#x7A7A;&#x6307;&#x9488;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#副作用返回值共存的运算符"><span class="nav-number">3.</span> <span class="nav-text"><a href="#&#x526F;&#x4F5C;&#x7528;&#x8FD4;&#x56DE;&#x503C;&#x5171;&#x5B58;&#x7684;&#x8FD0;&#x7B97;&#x7B26;" class="headerlink" title="&#x526F;&#x4F5C;&#x7528;&#x8FD4;&#x56DE;&#x503C;&#x5171;&#x5B58;&#x7684;&#x8FD0;&#x7B97;&#x7B26;"></a>&#x526F;&#x4F5C;&#x7528;&#x8FD4;&#x56DE;&#x503C;&#x5171;&#x5B58;&#x7684;&#x8FD0;&#x7B97;&#x7B26;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#未定义的求值顺序"><span class="nav-number">3.1.</span> <span class="nav-text"><a href="#&#x672A;&#x5B9A;&#x4E49;&#x7684;&#x6C42;&#x503C;&#x987A;&#x5E8F;" class="headerlink" title="&#x672A;&#x5B9A;&#x4E49;&#x7684;&#x6C42;&#x503C;&#x987A;&#x5E8F;"></a>&#x672A;&#x5B9A;&#x4E49;&#x7684;&#x6C42;&#x503C;&#x987A;&#x5E8F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值造成的另一个问题"><span class="nav-number">3.2.</span> <span class="nav-text"><a href="#&#x8FD4;&#x56DE;&#x503C;&#x9020;&#x6210;&#x7684;&#x53E6;&#x4E00;&#x4E2A;&#x95EE;&#x9898;" class="headerlink" title="&#x8FD4;&#x56DE;&#x503C;&#x9020;&#x6210;&#x7684;&#x53E6;&#x4E00;&#x4E2A;&#x95EE;&#x9898;"></a>&#x8FD4;&#x56DE;&#x503C;&#x9020;&#x6210;&#x7684;&#x53E6;&#x4E00;&#x4E2A;&#x95EE;&#x9898;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简陋的宏变换"><span class="nav-number">4.</span> <span class="nav-text"><a href="#&#x7B80;&#x964B;&#x7684;&#x5B8F;&#x53D8;&#x6362;" class="headerlink" title="&#x7B80;&#x964B;&#x7684;&#x5B8F;&#x53D8;&#x6362;"></a>&#x7B80;&#x964B;&#x7684;&#x5B8F;&#x53D8;&#x6362;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分号空语句"><span class="nav-number">5.</span> <span class="nav-text"><a href="#&#x5206;&#x53F7;&#x7A7A;&#x8BED;&#x53E5;" class="headerlink" title="&#x5206;&#x53F7;&#x7A7A;&#x8BED;&#x53E5;"></a>&#x5206;&#x53F7;&#x7A7A;&#x8BED;&#x53E5;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch默认fallthrough"><span class="nav-number">6.</span> <span class="nav-text"><a href="#switch&#x9ED8;&#x8BA4;fallthrough" class="headerlink" title="switch&#x9ED8;&#x8BA4;fallthrough"></a>switch&#x9ED8;&#x8BA4;fallthrough</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八进制整数字面量"><span class="nav-number">7.</span> <span class="nav-text"><a href="#&#x516B;&#x8FDB;&#x5236;&#x6574;&#x6570;&#x5B57;&#x9762;&#x91CF;" class="headerlink" title="&#x516B;&#x8FDB;&#x5236;&#x6574;&#x6570;&#x5B57;&#x9762;&#x91CF;"></a>&#x516B;&#x8FDB;&#x5236;&#x6574;&#x6570;&#x5B57;&#x9762;&#x91CF;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字类型名"><span class="nav-number">8.</span> <span class="nav-text"><a href="#&#x6570;&#x5B57;&#x7C7B;&#x578B;&#x540D;" class="headerlink" title="&#x6570;&#x5B57;&#x7C7B;&#x578B;&#x540D;"></a>&#x6570;&#x5B57;&#x7C7B;&#x578B;&#x540D;</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">vegarden</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><script type="text/javascript">var disqus_config=function(){this.page.url="https://vegarden.github.io/2017/02/08/bad-design-of-c/",this.page.identifier="2017/02/08/bad-design-of-c/",this.page.title="C的设计失误"},d=document,s=d.createElement("script");s.src="https://vegarden.disqus.com/embed.js",s.setAttribute("data-timestamp",""+ +new Date),(d.head||d.body).appendChild(s)</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){var r=!1,s=0,a=0,i=n.title.trim(),c=i.toLowerCase(),l=n.content.trim().replace(/<[^>]+>/g,""),h=l.toLowerCase(),p=decodeURIComponent(n.url),u=[],f=[];if(""!=i&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}u=u.concat(e(t,c,!1)),f=f.concat(e(t,h,!1))}),(u.length>0||f.length>0)&&(r=!0,s=u.length+f.length)),r){[u,f].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});function d(e,o,n,r){for(var s=r[r.length-1],i=s.position,c=s.word,l=[],h=0;i+c.length<=n&&0!=r.length;){c===t&&h++,l.push({position:i,length:c.length});var p=i+c.length;for(r.pop();0!=r.length&&(s=r[r.length-1],i=s.position,c=s.word,p>i);)r.pop()}return a+=h,{hits:l,start:o,end:n,searchTextCount:h}}var g=[];0!=u.length&&g.push(d(0,0,i.length,u));for(var v=[];0!=f.length;){var $=f[f.length-1],C=$.position,m=$.word,x=C-20,w=C+80;x<0&&(x=0),w<C+m.length&&(w=C+m.length),w>l.length&&(w=l.length),v.push(d(0,x,w,f))}v.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var y=parseInt("1");y>=0&&(v=v.slice(0,y));function T(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var b="";0!=g.length?b+="<li><a href='"+p+"' class='search-result-title'>"+T(i,g[0])+"</a>":b+="<li><a href='"+p+"' class='search-result-title'>"+i+"</a>",v.forEach(function(t){b+="<a href='"+p+'\'><p class="search-result">'+T(l,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:a,hitCount:s,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script></body></html>